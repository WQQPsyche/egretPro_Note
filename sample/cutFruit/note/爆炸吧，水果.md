## 《切水果》实战案例学习笔记

### 一、认识水果

​				--------认识组成模型的网格和材质

水果-->3D模型-->游戏实体

这些3D模型既可以从另一个程序导入的（比如3dmax or maya），也可以是程序生成的网格。

![](../note/images/3d%E6%A8%A1%E5%9E%8B%E5%9B%BE.png)

![](../note/images/3d%E6%A8%A1%E5%9E%8B%E5%9B%BE%E2%80%94%E2%80%94%E7%BD%91%E6%A0%BC.png)

在Pro中，在场景中创建一个cube或者拖拽进来一个3d模型，我们就会发现每一个模型都包含两个组件：

- MeshFilter 这个组件记录了你想要展示的网格数据
- MeshRenderer 使用这个组件告诉网格如何渲染，比如使用哪个材质球，是否接受阴影和其他设置。

![](../note/images/%E6%A8%A1%E5%9E%8B2%E4%B8%AA%E7%BB%84%E4%BB%B6.png)

切水果的游戏中，我们会发现水果被我们切成了一片一片的。这个时候我们就要用代码去创建模型了。所以本章节主要是带大家了解一些关于代码创建网格的知识。

#### mesh的属性

-  顶点坐标（vertex）

-  法线（normal）

-  纹理坐标（uv）

-  顶点索引

  

**顶点坐标**：顶点坐标数组存放Mesh的每个顶点的空间坐标，假设某mesh有n个顶点，每个顶点都是一个三维坐标点，则vertexs的长度为n*3

**法线**：法线数组存放mesh每个顶点的法线，normals的长度等于vertexs的长度

-  法线是垂直于面的向量。我们通常使用单位长度的法向量，并向量指向面的外部，而不是内部。
- 法线可以用于确定光线与顶点的夹角。

**纹理坐标**：它定义了图片上每个点的位置的信息. 这些点与3D模型是相互联系的, 以决定表面纹理贴图的位置. UV就是将图像上每一个点精确对应到模型物体的表面. uv[i]对应vertex[i]

**顶点索引**：每个mesh都由若干个三角形组成，而三角形的三个点就是顶点坐标里的点，这些点的连接顺序就是顶点索引。

接下来，编写一个组件，来打印log信息看看Plane,cube他们的mesh信息。

```typescript
import { component } from "@egret/ecs";
import { Behaviour } from "@egret/engine";
import { MeshFilter, Mesh } from "@egret/render";
import { AttributeSemantics } from "@egret/gltf";

@component()
class GetCubInfo extends Behaviour{
    onStart(){
        const mesh:Mesh = this.entity.getComponent(MeshFilter).mesh;
        console.log("顶点坐标___________________");
        console.log(mesh.getAttribute(AttributeSemantics.POSITION) );
        console.log("法线___________________");
        console.log(mesh.getAttribute(AttributeSemantics.NORMAL) );
        console.log("纹理贴图坐标0___________________");
        console.log(mesh.getAttribute(AttributeSemantics.TEXCOORD_0) );
        console.log("问题贴图坐标1___________________");
        console.log(mesh.getAttribute(AttributeSemantics.TEXCOORD_1));      
        console.log("顶点索引___________");
        console.log(mesh.getIndices());
    }
}
```



#### 创建Mesh

第一步，创建一个3d实体；

第二步，给实体添加MeshFilter与MeshRender组件；

第三步，用代码实现MeshFileter组件中的mesh属性；

第四步，给MeshRender中添加materails材质；

```typescript
    private async createPlaneDemo(){
    
        const plane = EngineFactory.createGameEntity3D("planeTest") as GameEntity;

        const meshFilter = plane.addComponent(MeshFilter);
        const meshRenderer = plane.addComponent(MeshRenderer);
        /**
         * 开始创建Mesh
         */
        //顶点坐标
        const vertices = [
            -0.5,0.5,0,
            0.5,0.5,0,
            0.5,-0.5,0,
            -0.5,-0.5,0            
        ];
        //法线：每个顶点的法线
        const normals = [
            0,0,-1,
            0,0,-1,
            0,0,-1,
            0,0,-1
        ];
        //uv坐标
 
        const uvs = [
            0,0,
            1,0,
            1,1,
            0,1
        ];

        // 顶点索引
        const indices = [
            0, 2, 1,
            0, 3, 2
        ];
        const mesh = Mesh.create(vertices.length / 3, indices.length);
        mesh.setAttribute(AttributeSemantics.POSITION, vertices);
        mesh.setAttribute(AttributeSemantics.NORMAL, normals);
        mesh.setAttribute(AttributeSemantics.TEXCOORD_0, uvs);
        mesh.setIndices(indices, 0);

        meshFilter.mesh = mesh;

        const testMaterial1 = await (await ResourceManager.instance.loadUri("assets/materials/logo.mat.json")).data;
        meshRenderer.material = testMaterial1;
    }
```

```typescript
    private async createBox(){
        const cube = EngineFactory.createGameEntity3D("cubeTest");

        const meshFilter = cube.addComponent(MeshFilter);
        const meshRender = cube.addComponent(MeshRenderer);

        const vertices = [
            //左
            -0.5,0.5,0.5,
            -0.5,0.5,-0.5,
            -0.5,-0.5,0.5,
            -0.5,-0.5,-0.5,
            //右
            0.5,0.5,-0.5,
            0.5,0.5,0.5,
            0.5,-0.5,-0.5,
            0.5,-0.5,0.5,
            //下
            -0.5,-0.5,-0.5,
            0.5,-0.5,-0.5,
            -0.5,-0.5,0.5,
            0.5,-0.5,0.5,
            //上
            -0.5,0.5,0.5,
            0.5,0.5,0.5,
            -0.5,0.5,-0.5,
            0.5,0.5,-0.5,
            //后
            -0.5,0.5,-0.5,
            0.5,0.5,-0.5,
            -0.5,-0.5,-0.5,
            0.5,-0.5,-0.5,
            //前
            0.5,0.5,0.5,
            -0.5,0.5,0.5,
            0.5,-0.5,0.5,
            -0.5,-0.5,0.5
        ];

        const normals = [
            //左
            -1,0,0,
            -1,0,0,
            -1,0,0,
            -1,0,0,
            //右
            1,0,0,
            1,0,0,
            1,0,0,
            1,0,0,
            //下
            0,-1,0,
            0,-1,0,
            0,-1,0,
            0,-1,0,
            //上
            0,1,0,
            0,1,0,
            0,1,0,
            0,1,0,
            //前
            0,0,-1,
            0,0,-1,
            0,0,-1,
            0,0,-1,
            // 后
            0,0,1,
            0,0,1,
            0,0,1,
            0,0,1
        ];
        const uvs = [
            0,0,
            1,0,
            0,1,
            1,1,

            0,0,
            1,0,
            0,1,
            1,1,

            0,0,
            1,0,
            0,1,
            1,1,

            0,0,
            1,0,
            0,1,
            1,1,

            0,0,
            1,0,
            0,1,
            1,1,

            0,0,
            1,0,
            0,1,
            1,1
        ]

        const indices = [
            0, 2, 1,
            2, 3, 1,
            4, 6, 5,
            6, 7, 5, 
            8, 10, 9, 
            10, 11, 9, 
            12, 14, 13, 
            14, 15, 13, 
            16, 18, 17, 
            18, 19, 17, 
            20, 22, 21, 
            22, 23, 21
        ];

        

        const mesh = Mesh.create(vertices.length / 3, indices.length);
        mesh.setAttribute(AttributeSemantics.POSITION, vertices);
        mesh.setAttribute(AttributeSemantics.NORMAL, normals);
        mesh.setAttribute(AttributeSemantics.TEXCOORD_0, uvs);
       
        mesh.setIndices(indices, 0);
        meshFilter.mesh = mesh;

        const testMaterial = await (await ResourceManager.instance.loadUri("assets/materials/logo.mat.json")).data;
        meshRender.material = testMaterial;
    }
```





参考链接：

[Unity Mesh网格编程(一) Mesh编程入门知识 代码显示网格、顶点、面、UV、法线、切线](https://blog.csdn.net/weixin_41717258/article/details/89395252)

[Unity网格编程篇(二) 非常详细的Mesh编程入门文章](https://blog.csdn.net/qq_29579137/article/details/77369734?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.edu_weight&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.edu_weight)

[Unity Mesh 立方体以及UV](https://www.jianshu.com/p/117f1293e77a)

[Unity Mesh(五) Mesh 立方体Cube贴图以及六个面分别贴不同的图片](https://blog.csdn.net/nanggong/article/details/54969867)



### 二、切下第一刀

​				--------如何将模型分割开

![](../note/images/%E5%88%87%E5%89%B2%E5%8A%A8%E6%80%81.gif)

#### **思路：**

1. **确定切线的平面**
2. **根据切面将模型的顶点分类切面的上/下 两部分。**
3. **对顶点间的连线进行顶点补充，并顺序连接顶点。**
4. **将切开的剖面顶点进行排序、补面、设置UV等。**

![](../note/images/%E4%B8%89%E8%A7%92%E5%BD%A2.png)nj



如图:当三角形abc被x轴切开时,

我们先求出ab和oa在y轴上的投影:

既 oay = Vector.Dot(a-o,y-o);

bay = Vector.Dot(a-b,y-o);

然后求出他们在y轴上的投影比：

scale = oay/bay;

然后d的位置就相当于以a为起点，在ab的方向移动了scale的比例.

d = a+(b-a)*scale;





### 三、新的切面如何产生

​				--------切开的模型两半补面

### 四、快刀切水果	

​				--------添加刀的动画

### 五、切换水果&优化

### 六、爆汁效果&2dUI界面

### 七、项目发布

